PROJEKT:
- Projekt komunikacji i synchronizacji na koncepcji monitora
- Monitor definiować w środowisku rozproszonym
1) mechanizm trybu wyłącznego
2) budzenie/uśpienie wątków
3) mechanizm zmiennych warunkowych

class Buffer : public Mój_Monitor {
protected:
    conditional c1, c2;
public:
    void put() {
        lock();
        ....
        unlock()
    }
}

class MutexWrapper {
    private:
        Mutex d_mutex;
    public:
        MutexWrapper(Mutex &m):d_mutex(m) {
            d_mutex.lock();
        }
        ~MutexWrapper() {
            d_mutex.unlock();
        }
}

void put() {
    MutexWrapper w(nazwa_mutexa);   // konstruktor
    ...
    // na końcu metody uruchamia  się destruktor (więc nie może być to klasa static)
}

mogę powiedzieć profesorowi, że w Monitorze jest taka metoda d_lock() i d_unlock(), której trzeba użyć w put().
Albo np. żeby w pucie utworzyć obiekt, który jest niepotrzebny ogółem, ale który ma automatyczny kontruktor lub destruktor, który robi potrzebne rzeczy.

c1, c2 - jesli wymagają parametru do stworzenia to też można powiedzieć

pvm, !mpi, 0mq - komunikacja rozproszona, może być coś innego

centralny dostęp - już gorzej

przy zmianiach komputery muszą przesyłać stan buffera

-------


np w momencie startu może być jakiś jeden serwer centralny. Ale nie na dłuższą metę, nie ma służyć do synchronizacji.
dobry deal - statyczna konfiguracja w pliku do wykorzystania na początku (jakies numery portów, potrzebne do inicjalizacji)
dynamiczne dołączanie nie jest wymagane. czyli grupa procesów jest statyczna np. w pliku konfiguracyjnym

różne rozwiązania:
1. algorytmy przy zmianie rozgłaszanie z potwierdzeniem (np ricard-agravala)
2. rozwiązanie z tokenem np. https://en.wikipedia.org/wiki/Suzuki%E2%80%93Kasami_algorithm
docenione: jeśli wątek wyjdzie z waita to zeby miał pierwszeństwo

Uruchamianie:

Jeżeli chcesz mieć protipa jak debugowac programy w MPI to Ci sprzedam taki sposób który
sobie wypracowałem robiąc program na PRy z Danileckim
w mainie programu jakoś na początku (przed częscią gdzie zaczynasz uruchamiac wątki i
tak dalej) deklarujesz zmienną bool debug = true
i dalej while (debug);
co powoduje ze program bedzie czekal na tej instrukcji w nieskonczonosc
budujesz ten program i odpalasz go przez mpirun
np uruchamiając z opcją 4 procesów mpirun -np 4
teraz w CLionie masz taka opcje Run -> Attach to local process czy jakoś tak
bedziesz musiała się tak podłączyć 4 razy, bo tyle procesów MPI uruchomiłaś
i potem otworzą Ci sie 4 okna debugowania w clionie
takie jak zwykłe debugowanie
i wtedy 4 razy zmieniasz w debuggerze wartość zmiennej debug na false i puszczasz
każdy proces dalej (F9)
upierdliwe ale działa

Opis Krzysia
Trzeba napisać mechanizm (Darek proponował klasę, którą on sobie będzie mógł rozszerzyć i napisać z
jej użyciem jakiś problem wymagający synchronizacji np producent-konsument) który będzie się zachowywac
jak typowy monitor, tylko działający w środowisku rozproszonym. Czyli jak wejdziesz w jedną z funkcji
(zwanych też wejściami) monitora, to do pozostałych funkcji monitora nie da się wejść dopóki ta
wykonywana zostanie zakończona. Jeśli chodzi o mutexy to tylko to trzeba zagwarantować - g_mutex na
poziomie całej metody (jak słowo synchronized w definicji funkcji w Javie). Musisz też udostępnić
 mechanizm zmiennych warunkowych, żeby proces który wejdzie do funkcji monitora i stwierdzi że nie
 może kontynuować, mógł pozwolić innym procesom działać na monitorze aż nie zostanie obudzony.
 Trzecią i ostatnią rzeczą jaką musisz zapewnić jest synchronizacja danych miedzy procesami (np
 w przypadku producenta-konsumenta będziesz chciał synchronizować zawartośc bufora pomędzy procesami,
  ale ma to działać dla dowolnego problemu).
  std::thread
  std::g_mutex
  std::condition_variable
  mpirun -np 4 a.out

  http://en.cppreference.com/w/cpp/thread/condition_variable
    https://developers.google.com/protocol-buffers/docs/cpptutorial

TL;DR: Masz zapewnić w możliwie transparentny sposób i wygodny dla programisty w użyciu:
1) Synchronizację dostępu na poziomie metody (zajęcie jednej metody monitora blokuje możliwość
zajmowania wszystkich pozostałych)
2) Mechanizm zmiennych warunkowych
3) Synchronizację danych

Wszystko ma działać w środowisku rozproszonym.
Jak to zrobisz oraz jakie mechanizmy komunikacji czy algorytmy rozproszone wykorzystasz do
zagwarantowania tego nie są narzucone.

openmpi savethread flag

w konstruktorze zmiennej warunkowej ma być g_mutex

//    MultiprocessDebugHelper::setup(15000 + connection->getId());

// wymaga zainstalowania https://www.boost.org/

// PRODUCENT / KONSUMENT

#include<stdio.h>
#include<pthread.h>
#include<stdlib.h>

int buf;	           // wspolny bufor
char flag = 0;              // 0 - pusty bufor, 1 - cos w buforze
// volatile char flag = 0;  //powstrzymuje kompilator optymalizujący w wypadku kolejnych odczytow lub zapisów zmiennej przed zastąpieniem jej tymczasową stałą, lub pomijaniem nadpisań
pthread_cond_t c = PTHREAD_COND_INITIALIZER;    // zmienna warunkowa
pthread_mutex_t m = PTHREAD_MUTEX_INITIALIZER;

void* prod(void* p) {       // producent
    int i;
    for (i = 0; i < 100; i++) {
        pthread_mutex_lock(&m);

        // if (flag == 1)       // while lepszy
        while (flag == 1)
            pthread_cond_wait(&c, &m);
        buf = i;
        flag = 1;

        pthread_cond_signal(&c);
        pthread_mutex_unlock(&m);
    }
}

void* cons(void* p) {       // konsument
    for (int i = 0; i < 100; i++) {
        pthread_mutex_lock(&m);

        while (flag == 0)
            pthread_cond_wait(&c, &m);

        // cos

        pthread_cond_signal(&c); // tracimy sygnal jesli zostanie wyslany przed waitem producenta
        pthread_mutex_unlock(&m);
    }
}

int main() {
    pthread_t thread_1;
    if(pthread_create(&thread_1, NULL, prod, NULL)) {
        fprintf(stderr, "Error creating thread_1\n");
        return 1;
    }
    cons(NULL);

    pthread_join(thread_1, NULL);

    return 0;
}
